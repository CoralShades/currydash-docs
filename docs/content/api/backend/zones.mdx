---
title: Zone Management
description: Service zone endpoints for checking delivery coverage and retrieving zone information
---

import { Callout, Steps, Tabs } from 'nextra/components'

# Zone Management

Public endpoints for retrieving service zones and checking delivery availability based on geographic location.

<Callout type="info">
  Zone Management endpoints are **publicly accessible** and do not require authentication. They are essential for determining service availability before order placement.
</Callout>

## Overview

The CurryDash zone system provides:

- **Service Area Definition**: Polygon-based geographic zones for delivery coverage
- **Real-time Availability**: Check if a location is within serviceable areas
- **Zone-based Filtering**: Filter restaurants and content by user location
- **Dynamic Coverage**: Zones can be activated/deactivated by administrators

### Use Cases

| Use Case | Endpoint | Purpose |
|----------|----------|---------|
| App Initialization | `GET /zone/list` | Load all available service zones on app startup |
| Address Validation | `GET /zone/check` | Verify delivery address is serviceable before checkout |
| Restaurant Filtering | `GET /zone/list` | Display zone-specific restaurants and content |
| Service Availability | `GET /zone/check` | Show coverage status on landing pages |

---

## Endpoints

### List Zones

Retrieve all active service zones with their geographic boundaries and metadata.

#### GET `/api/v1/zone/list`

**Controller**: `App\Http\Controllers\Api\V1\ZoneController@get_zones`

**Authentication**: Not required (public)

**Rate Limit**: 60 requests/minute per IP

**Query Parameters**: None

**Success Response** (200 OK):

```json
[
  {
    "id": 1,
    "name": "Melbourne CBD",
    "coordinates": [
      {"lat": -37.8136, "lng": 144.9631},
      {"lat": -37.8186, "lng": 144.9681},
      {"lat": -37.8236, "lng": 144.9731},
      {"lat": -37.8186, "lng": 144.9781},
      {"lat": -37.8136, "lng": 144.9731}
    ],
    "status": true,
    "created_at": "2025-11-01T08:00:00.000000Z",
    "updated_at": "2025-12-01T10:30:00.000000Z"
  },
  {
    "id": 2,
    "name": "Richmond",
    "coordinates": [
      {"lat": -37.8200, "lng": 145.0000},
      {"lat": -37.8300, "lng": 145.0100},
      {"lat": -37.8400, "lng": 145.0050},
      {"lat": -37.8300, "lng": 144.9950}
    ],
    "status": true,
    "created_at": "2025-11-05T12:00:00.000000Z",
    "updated_at": "2025-11-20T14:15:00.000000Z"
  },
  {
    "id": 3,
    "name": "St Kilda",
    "coordinates": [
      {"lat": -37.8670, "lng": 144.9730},
      {"lat": -37.8720, "lng": 144.9830},
      {"lat": -37.8670, "lng": 144.9930}
    ],
    "status": true,
    "created_at": "2025-11-10T09:30:00.000000Z",
    "updated_at": "2025-12-05T11:00:00.000000Z"
  }
]
```

**Response Fields**:

| Field | Type | Description |
|-------|------|-------------|
| `id` | integer | Unique zone identifier |
| `name` | string | Human-readable zone name (e.g., "Melbourne CBD") |
| `coordinates` | array | Polygon vertices defining zone boundary (lat/lng pairs) |
| `status` | boolean | `true` if zone is active, `false` if disabled |
| `created_at` | timestamp | Zone creation timestamp (ISO 8601 format) |
| `updated_at` | timestamp | Last modification timestamp (ISO 8601 format) |

**Error Response** (500 Internal Server Error):

```json
{
  "errors": [
    {
      "code": "server-001",
      "message": "Unable to retrieve zones. Please try again later."
    }
  ]
}
```

<Callout type="info">
  **Coordinate Format**: Coordinates are returned as latitude/longitude pairs forming a closed polygon. The first and last coordinates typically match to close the polygon boundary.
</Callout>

**Business Logic**:

<Steps>

### Database Query

System retrieves all zones with `status = 1` (active zones only).

### Coordinate Parsing

Polygon coordinates stored in database are parsed from GeoJSON format.

### Response Formation

Zones are serialized with id, name, coordinates array, and metadata.

### Caching

Zone data is cached for 1 hour to improve performance (configurable).

</Steps>

**Client Implementation Example**:

<Tabs items={['PHP/Laravel', 'JavaScript', 'Flutter', 'cURL']}>
  <Tabs.Tab>
    ```php
    use Illuminate\Support\Facades\Http;
    use Illuminate\Http\Client\RequestException;
    use Illuminate\Support\Facades\Cache;
    use Illuminate\Support\Facades\Log;

    /**
     * Fetch all active service zones
     *
     * @return \Illuminate\Http\JsonResponse
     */
    public function getServiceZones()
    {
        try {
            // Try to get zones from cache first (1 hour cache)
            $zones = Cache::remember('service_zones', 3600, function () {
                $response = Http::timeout(10)
                    ->get('https://api.currydash.au/api/v1/zone/list');

                if ($response->successful()) {
                    return $response->json();
                }

                // If request fails, throw exception to skip caching
                throw new \Exception('Failed to fetch zones');
            });

            return response()->json([
                'success' => true,
                'zones' => $zones,
                'cached' => true,
            ]);

        } catch (RequestException $e) {
            // Handle network or timeout errors
            Log::error('Zone list request failed', [
                'error' => $e->getMessage(),
                'status' => $e->response?->status(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Unable to retrieve service zones',
                'errors' => [
                    [
                        'code' => 'network-error',
                        'message' => 'Connection to zone service failed',
                    ]
                ],
            ], 500);

        } catch (\Exception $e) {
            // Handle other errors
            Log::error('Unexpected error fetching zones', [
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Failed to load zones',
                'errors' => [
                    [
                        'code' => 'server-error',
                        'message' => $e->getMessage(),
                    ]
                ],
            ], 500);
        }
    }

    /**
     * Process zones for display on map
     *
     * @return array
     */
    public function getZonesForMap()
    {
        try {
            $response = Http::get('https://api.currydash.au/api/v1/zone/list');

            if ($response->successful()) {
                $zones = $response->json();

                // Transform zones for frontend map rendering
                $mapZones = collect($zones)->map(function ($zone) {
                    return [
                        'id' => $zone['id'],
                        'name' => $zone['name'],
                        'polygon' => $zone['coordinates'],
                        'isActive' => $zone['status'],
                        'color' => '#FF6B35', // CurryDash brand color
                    ];
                })->toArray();

                return response()->json([
                    'success' => true,
                    'zones' => $mapZones,
                ]);
            }

            // Handle server errors (500)
            if ($response->status() === 500) {
                return response()->json([
                    'success' => false,
                    'message' => 'Zone service temporarily unavailable',
                ], 500);
            }

            return response()->json([
                'success' => false,
                'message' => 'Failed to retrieve zones',
            ], $response->status());

        } catch (RequestException $e) {
            Log::error('Failed to fetch zones for map', [
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Unable to load zone map data',
            ], 500);
        }
    }
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript
    // Fetch zones and render on map
    const loadServiceZones = async () => {
      try {
        const response = await fetch('https://currydash.au/api/v1/zone/list');
        const zones = await response.json();

        // Render zones on Google Maps
        zones.forEach(zone => {
          const polygon = new google.maps.Polygon({
            paths: zone.coordinates.map(c => ({ lat: c.lat, lng: c.lng })),
            strokeColor: '#FF6B35',
            strokeOpacity: 0.8,
            strokeWeight: 2,
            fillColor: '#FF6B35',
            fillOpacity: 0.15
          });
          polygon.setMap(map);
        });
      } catch (error) {
        console.error('Failed to load zones:', error);
      }
    };
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```dart
    import 'dart:convert';
    import 'package:http/http.dart' as http;

    /// Fetch all active service zones
    Future<Map<String, dynamic>> getServiceZones() async {
      try {
        final response = await http.get(
          Uri.parse('https://api.currydash.au/api/v1/zone/list'),
          headers: {
            'Accept': 'application/json',
          },
        );

        if (response.statusCode == 200) {
          final List<dynamic> zones = jsonDecode(response.body);

          return {
            'success': true,
            'zones': zones,
            'count': zones.length,
          };
        }

        // Handle server errors (500)
        if (response.statusCode == 500) {
          final error = jsonDecode(response.body);
          final errors = error['errors'] ?? [];

          return {
            'success': false,
            'message': 'Unable to retrieve zones. Please try again later.',
            'errors': errors,
          };
        }

        // Handle other errors
        return {
          'success': false,
          'message': 'Failed to retrieve zones',
        };

      } catch (e) {
        // Handle network or timeout errors
        debugPrint('Zone list request failed: $e');

        return {
          'success': false,
          'message': 'Unable to retrieve service zones',
          'errors': [
            {
              'code': 'network-error',
              'message': 'Connection to zone service failed',
            }
          ],
        };
      }
    }

    /// Process zones for display on map
    Future<Map<String, dynamic>> getZonesForMap() async {
      try {
        final response = await http.get(
          Uri.parse('https://api.currydash.au/api/v1/zone/list'),
          headers: {
            'Accept': 'application/json',
          },
        );

        if (response.statusCode == 200) {
          final List<dynamic> zones = jsonDecode(response.body);

          // Transform zones for map rendering
          final mapZones = zones.map((zone) {
            return {
              'id': zone['id'],
              'name': zone['name'],
              'polygon': zone['coordinates'],
              'isActive': zone['status'],
              'color': '#FF6B35', // CurryDash brand color
            };
          }).toList();

          return {
            'success': true,
            'zones': mapZones,
          };
        }

        // Handle server errors (500)
        if (response.statusCode == 500) {
          return {
            'success': false,
            'message': 'Zone service temporarily unavailable',
          };
        }

        return {
          'success': false,
          'message': 'Failed to retrieve zones',
        };

      } catch (e) {
        debugPrint('Failed to fetch zones for map: $e');

        return {
          'success': false,
          'message': 'Unable to load zone map data',
        };
      }
    }
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```bash
    curl -X GET "https://currydash.au/api/v1/zone/list" \
      -H "Accept: application/json"
    ```
  </Tabs.Tab>
</Tabs>

---

### Check Zone

Validate if a specific geographic coordinate is within a serviceable delivery zone.

#### GET `/api/v1/zone/check`

**Controller**: `App\Http\Controllers\Api\V1\ZoneController@zonesCheck`

**Authentication**: Not required (public)

**Rate Limit**: 60 requests/minute per IP

**Query Parameters**:

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `lat` | float | Yes | Latitude coordinate (decimal degrees, e.g., -37.8136) |
| `lng` | float | Yes | Longitude coordinate (decimal degrees, e.g., 144.9631) |

**Example Request**:

```
GET /api/v1/zone/check?lat=-37.8136&lng=144.9631
```

**Validation Rules**:

```php
[
    'lat' => 'required|numeric|between:-90,90',
    'lng' => 'required|numeric|between:-180,180',
]
```

**Success Response** (200 OK):

```json
{
  "zone_id": 1,
  "zone_name": "Melbourne CBD",
  "serviceable": true
}
```

**Response Fields**:

| Field | Type | Description |
|-------|------|-------------|
| `zone_id` | integer | ID of the zone containing this location |
| `zone_name` | string | Name of the serviceable zone |
| `serviceable` | boolean | `true` if location is within zone, `false` otherwise |

**Error Response** (404 Not Found):

```json
{
  "errors": [
    {
      "code": "zone-001",
      "message": "Service not available in this area"
    }
  ]
}
```

**Error Response** (422 Unprocessable Entity):

```json
{
  "errors": [
    {
      "code": "validation-001",
      "message": "The lat field is required.",
      "field": "lat"
    }
  ]
}
```

<Callout type="warning">
  **Coordinate Accuracy**: Ensure latitude/longitude values have at least 4 decimal places for accurate zone detection. Coordinates with insufficient precision may produce incorrect results.
</Callout>

**Business Logic**:

<Steps>

### Parameter Validation

System validates `lat` and `lng` are valid decimal coordinates.

### Zone Iteration

For each active zone, perform point-in-polygon check using ray-casting algorithm.

### Match Detection

If point falls within polygon boundary, return zone details with `serviceable: true`.

### No Match

If no zones contain the point, return 404 error with "Service not available" message.

</Steps>

**Point-in-Polygon Algorithm**:

The system uses the **Ray Casting Algorithm** to determine if a coordinate point is inside a zone polygon:

```php
// Simplified server-side implementation
public function isPointInPolygon($point, $polygon)
{
    $x = $point['lng'];
    $y = $point['lat'];
    $inside = false;

    for ($i = 0, $j = count($polygon) - 1; $i < count($polygon); $j = $i++) {
        $xi = $polygon[$i]['lng'];
        $yi = $polygon[$i]['lat'];
        $xj = $polygon[$j]['lng'];
        $yj = $polygon[$j]['lat'];

        $intersect = (($yi > $y) != ($yj > $y))
            && ($x < ($xj - $xi) * ($y - $yi) / ($yj - $yi) + $xi);

        if ($intersect) {
            $inside = !$inside;
        }
    }

    return $inside;
}
```

**Client Implementation Example**:

<Tabs items={['PHP/Laravel', 'JavaScript', 'Flutter', 'cURL']}>
  <Tabs.Tab>
    ```php
    use Illuminate\Support\Facades\Http;
    use Illuminate\Http\Client\RequestException;
    use Illuminate\Support\Facades\Log;
    use Illuminate\Support\Facades\Validator;

    /**
     * Check if coordinates are within a serviceable zone
     *
     * @param float $latitude
     * @param float $longitude
     * @return \Illuminate\Http\JsonResponse
     */
    public function checkZoneAvailability($latitude, $longitude)
    {
        // Validate coordinates
        $validator = Validator::make([
            'lat' => $latitude,
            'lng' => $longitude,
        ], [
            'lat' => 'required|numeric|between:-90,90',
            'lng' => 'required|numeric|between:-180,180',
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'message' => 'Invalid coordinates',
                'errors' => $validator->errors(),
            ], 422);
        }

        try {
            $response = Http::timeout(10)
                ->get('https://api.currydash.au/api/v1/zone/check', [
                    'lat' => $latitude,
                    'lng' => $longitude,
                ]);

            // Success - location is serviceable
            if ($response->successful()) {
                $data = $response->json();

                // Store zone info in session for future requests
                session([
                    'current_zone_id' => $data['zone_id'],
                    'current_zone_name' => $data['zone_name'],
                ]);

                return response()->json([
                    'success' => true,
                    'serviceable' => $data['serviceable'],
                    'zone' => [
                        'id' => $data['zone_id'],
                        'name' => $data['zone_name'],
                    ],
                ]);
            }

            // Handle 404 - location not serviceable
            if ($response->status() === 404) {
                $error = $response->json();

                return response()->json([
                    'success' => false,
                    'serviceable' => false,
                    'message' => 'Service not available in this area',
                    'errors' => $error['errors'] ?? [],
                ], 404);
            }

            // Handle validation errors (422)
            if ($response->status() === 422) {
                return response()->json([
                    'success' => false,
                    'message' => 'Invalid request parameters',
                    'errors' => $response->json('errors', []),
                ], 422);
            }

            // Handle other errors
            return response()->json([
                'success' => false,
                'message' => 'Failed to check zone availability',
            ], $response->status());

        } catch (RequestException $e) {
            // Handle network or timeout errors
            Log::error('Zone check request failed', [
                'latitude' => $latitude,
                'longitude' => $longitude,
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Unable to verify service availability',
                'errors' => [
                    [
                        'code' => 'network-error',
                        'message' => 'Connection failed',
                    ]
                ],
            ], 500);
        }
    }

    /**
     * Validate delivery address and check zone
     *
     * @param \Illuminate\Http\Request $request
     * @return \Illuminate\Http\JsonResponse
     */
    public function validateDeliveryAddress(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'address' => 'required|string|max:255',
            'latitude' => 'required|numeric|between:-90,90',
            'longitude' => 'required|numeric|between:-180,180',
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'errors' => $validator->errors(),
            ], 422);
        }

        try {
            $response = Http::get('https://api.currydash.au/api/v1/zone/check', [
                'lat' => $request->latitude,
                'lng' => $request->longitude,
            ]);

            if ($response->successful()) {
                $zoneData = $response->json();

                // Address is serviceable - proceed with order
                return response()->json([
                    'success' => true,
                    'serviceable' => true,
                    'message' => "Great! We deliver to {$zoneData['zone_name']}",
                    'zone' => [
                        'id' => $zoneData['zone_id'],
                        'name' => $zoneData['zone_name'],
                    ],
                    'address' => $request->address,
                ]);
            }

            // Address not serviceable
            if ($response->status() === 404) {
                return response()->json([
                    'success' => false,
                    'serviceable' => false,
                    'message' => 'Sorry, we don\'t deliver to this area yet',
                    'suggestion' => 'Try a different address or check back later',
                ], 404);
            }

            return response()->json([
                'success' => false,
                'message' => 'Unable to validate address',
            ], $response->status());

        } catch (RequestException $e) {
            Log::error('Address validation failed', [
                'address' => $request->address,
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Unable to validate delivery address',
            ], 500);
        }
    }

    /**
     * Get restaurants available in user's zone
     *
     * @param float $latitude
     * @param float $longitude
     * @return \Illuminate\Http\JsonResponse
     */
    public function getRestaurantsByLocation($latitude, $longitude)
    {
        try {
            // First, check which zone the user is in
            $zoneResponse = Http::get('https://api.currydash.au/api/v1/zone/check', [
                'lat' => $latitude,
                'lng' => $longitude,
            ]);

            if ($zoneResponse->status() === 404) {
                return response()->json([
                    'success' => false,
                    'serviceable' => false,
                    'message' => 'No restaurants available in your area',
                    'restaurants' => [],
                ], 404);
            }

            if ($zoneResponse->successful()) {
                $zone = $zoneResponse->json();

                // Fetch restaurants for this zone
                // (This would call your internal restaurant API)
                $restaurants = $this->getRestaurantsByZoneId($zone['zone_id']);

                return response()->json([
                    'success' => true,
                    'zone' => $zone,
                    'restaurants' => $restaurants,
                    'count' => count($restaurants),
                ]);
            }

            return response()->json([
                'success' => false,
                'message' => 'Failed to determine service area',
            ], $zoneResponse->status());

        } catch (RequestException $e) {
            Log::error('Failed to get restaurants by location', [
                'latitude' => $latitude,
                'longitude' => $longitude,
                'error' => $e->getMessage(),
            ]);

            return response()->json([
                'success' => false,
                'message' => 'Unable to load restaurants',
            ], 500);
        }
    }
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```javascript
    // Check if user location is serviceable
    const checkServiceAvailability = async (latitude, longitude) => {
      try {
        const response = await fetch(
          `https://currydash.au/api/v1/zone/check?lat=${latitude}&lng=${longitude}`
        );

        if (response.ok) {
          const data = await response.json();
          console.log(`Service available in ${data.zone_name}`);
          return data;
        } else if (response.status === 404) {
          console.log('Sorry, we don\'t deliver to this area yet');
          return null;
        }
      } catch (error) {
        console.error('Zone check failed:', error);
        return null;
      }
    };

    // Usage with browser geolocation
    navigator.geolocation.getCurrentPosition(async (position) => {
      const zone = await checkServiceAvailability(
        position.coords.latitude,
        position.coords.longitude
      );
      if (zone) {
        // User is in serviceable zone - proceed to app
        loadRestaurants(zone.zone_id);
      } else {
        // Show "not available" message
        showNotAvailableMessage();
      }
    });
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```dart
    import 'dart:convert';
    import 'package:http/http.dart' as http;

    /// Check if coordinates are within a serviceable zone
    Future<Map<String, dynamic>> checkZoneAvailability({
      required double latitude,
      required double longitude,
    }) async {
      try {
        final response = await http.get(
          Uri.parse(
            'https://api.currydash.au/api/v1/zone/check'
            '?lat=$latitude&lng=$longitude'
          ),
          headers: {
            'Accept': 'application/json',
          },
        );

        // Success - location is serviceable
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);

          return {
            'success': true,
            'serviceable': data['serviceable'],
            'zone': {
              'id': data['zone_id'],
              'name': data['zone_name'],
            },
          };
        }

        // Handle 404 - location not serviceable
        if (response.statusCode == 404) {
          final error = jsonDecode(response.body);

          return {
            'success': false,
            'serviceable': false,
            'message': 'Service not available in this area',
            'errors': error['errors'] ?? [],
          };
        }

        // Handle validation errors (422)
        if (response.statusCode == 422) {
          final error = jsonDecode(response.body);

          return {
            'success': false,
            'message': 'Invalid request parameters',
            'errors': error['errors'] ?? [],
          };
        }

        // Handle other errors
        return {
          'success': false,
          'message': 'Failed to check zone availability',
        };

      } catch (e) {
        // Handle network or timeout errors
        debugPrint('Zone check request failed: $e');

        return {
          'success': false,
          'message': 'Unable to verify service availability',
          'errors': [
            {
              'code': 'network-error',
              'message': 'Connection failed',
            }
          ],
        };
      }
    }

    /// Validate delivery address and check zone
    Future<Map<String, dynamic>> validateDeliveryAddress({
      required String address,
      required double latitude,
      required double longitude,
    }) async {
      try {
        final response = await http.get(
          Uri.parse(
            'https://api.currydash.au/api/v1/zone/check'
            '?lat=$latitude&lng=$longitude'
          ),
          headers: {
            'Accept': 'application/json',
          },
        );

        if (response.statusCode == 200) {
          final zoneData = jsonDecode(response.body);

          // Address is serviceable - proceed with order
          return {
            'success': true,
            'serviceable': true,
            'message': 'Great! We deliver to ${zoneData['zone_name']}',
            'zone': {
              'id': zoneData['zone_id'],
              'name': zoneData['zone_name'],
            },
            'address': address,
          };
        }

        // Address not serviceable
        if (response.statusCode == 404) {
          return {
            'success': false,
            'serviceable': false,
            'message': 'Sorry, we don\'t deliver to this area yet',
            'suggestion': 'Try a different address or check back later',
          };
        }

        return {
          'success': false,
          'message': 'Unable to validate address',
        };

      } catch (e) {
        debugPrint('Address validation failed: $e');

        return {
          'success': false,
          'message': 'Unable to validate delivery address',
        };
      }
    }

    /// Get restaurants available in user's zone
    Future<Map<String, dynamic>> getRestaurantsByLocation({
      required double latitude,
      required double longitude,
    }) async {
      try {
        // First, check which zone the user is in
        final zoneResponse = await http.get(
          Uri.parse(
            'https://api.currydash.au/api/v1/zone/check'
            '?lat=$latitude&lng=$longitude'
          ),
          headers: {
            'Accept': 'application/json',
          },
        );

        if (zoneResponse.statusCode == 404) {
          return {
            'success': false,
            'serviceable': false,
            'message': 'No restaurants available in your area',
            'restaurants': [],
          };
        }

        if (zoneResponse.statusCode == 200) {
          final zone = jsonDecode(zoneResponse.body);

          // Fetch restaurants for this zone
          // (This would call your restaurant API with zone_id filter)
          final restaurants = await _getRestaurantsByZoneId(zone['zone_id']);

          return {
            'success': true,
            'zone': zone,
            'restaurants': restaurants,
            'count': restaurants.length,
          };
        }

        return {
          'success': false,
          'message': 'Failed to determine service area',
        };

      } catch (e) {
        debugPrint('Failed to get restaurants by location: $e');

        return {
          'success': false,
          'message': 'Unable to load restaurants',
        };
      }
    }

    /// Helper function to fetch restaurants by zone ID
    Future<List<dynamic>> _getRestaurantsByZoneId(int zoneId) async {
      // Implementation would call your restaurant API
      // This is a placeholder
      return [];
    }
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```bash
    # Check if Melbourne CBD location is serviceable
    curl -X GET "https://currydash.au/api/v1/zone/check?lat=-37.8136&lng=144.9631" \
      -H "Accept: application/json"

    # Response (serviceable):
    # {
    #   "zone_id": 1,
    #   "zone_name": "Melbourne CBD",
    #   "serviceable": true
    # }

    # Check non-serviceable location
    curl -X GET "https://currydash.au/api/v1/zone/check?lat=-38.0000&lng=145.0000" \
      -H "Accept: application/json"

    # Response (404 Not Found):
    # {
    #   "errors": [
    #     {
    #       "code": "zone-001",
    #       "message": "Service not available in this area"
    #     }
    #   ]
    # }
    ```
  </Tabs.Tab>
</Tabs>

---

## Error Codes

Zone Management endpoints may return these error codes:

| Code | Message | HTTP Status | Description |
|------|---------|-------------|-------------|
| `zone-001` | Service not available in this area | 404 | Coordinates are outside all service zones |
| `validation-001` | Required field missing | 422 | `lat` or `lng` parameter missing |
| `validation-002` | Invalid format | 422 | Coordinates not valid decimal numbers |
| `server-001` | Unable to retrieve zones | 500 | Database or caching error |
| `rate-limit-001` | Too many requests | 429 | Rate limit exceeded (60 req/min) |

---

## Integration Guidelines

<Callout type="info">
  **Best Practice**: Call `/zone/list` once on app startup and cache the results. Use `/zone/check` whenever user enters a new address or updates their location.
</Callout>

### Recommended Flow

<Steps>

### App Initialization

Fetch all zones using `GET /zone/list` and cache for 24 hours.

### User Location Detection

Get user's current location via GPS or IP geolocation.

### Zone Validation

Call `GET /zone/check` with user coordinates to verify serviceability.

### Content Filtering

If serviceable, use `zone_id` to filter restaurants and packages.

### Fallback Handling

If not serviceable, show "coming soon" message with zone expansion roadmap.

</Steps>

### Caching Strategy

**Client-Side Caching**:
- **Zone List**: Cache for 24 hours (zones change infrequently)
- **Zone Checks**: Cache by coordinates for 1 hour (user location stable during session)
- **Invalidation**: Clear cache on app update or user-triggered refresh

**Example (React Native + AsyncStorage)**:

```javascript
const ZONE_CACHE_KEY = 'service_zones';
const ZONE_CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours

const getCachedZones = async () => {
  const cached = await AsyncStorage.getItem(ZONE_CACHE_KEY);
  if (!cached) return null;

  const { zones, timestamp } = JSON.parse(cached);
  const isExpired = Date.now() - timestamp > ZONE_CACHE_DURATION;

  return isExpired ? null : zones;
};

const loadZones = async () => {
  // Try cache first
  let zones = await getCachedZones();
  if (zones) return zones;

  // Fetch from API
  const response = await fetch('https://currydash.au/api/v1/zone/list');
  zones = await response.json();

  // Cache results
  await AsyncStorage.setItem(ZONE_CACHE_KEY, JSON.stringify({
    zones,
    timestamp: Date.now()
  }));

  return zones;
};
```

---

## Performance Considerations

### Server-Side Optimizations

- **Database Indexing**: Zone queries use spatial indexes for fast polygon lookups
- **Result Caching**: Zone list is cached in Redis for 1 hour (configurable)
- **Point-in-Polygon**: Uses optimized ray-casting algorithm with early exit
- **Query Optimization**: Only active zones (`status = 1`) are queried

### Response Times

| Endpoint | Avg Response Time | Cache Hit Rate |
|----------|------------------|----------------|
| `GET /zone/list` | 50-100ms (uncached) | 95% |
| `GET /zone/list` | 5-15ms (cached) | - |
| `GET /zone/check` | 30-80ms | N/A |

---

## Related Documentation

- **[Backend API Overview](/api/backend)**: Complete API reference and standards
- **[Restaurant Endpoints](/api/backend/restaurants)**: Filter restaurants by zone
- **[Data Flow](/developers/backend/architecture/data-flow)**: Zone data model and request flow
- **[Business Logic - Delivery Rules](/developers/backend/architecture/service-layer-business-logic#delivery-zones)**: Zone-based delivery calculations
