---
title: Getting Started with CurryDash API
description: Quick start guide for integrating CurryDash API into your Flutter application
---

import { Callout, Steps, Tabs } from 'nextra/components'

# Getting Started with CurryDash API

This guide will help you quickly integrate the CurryDash API into your Flutter mobile or web application.

<Callout type="info">
  This guide assumes you have basic knowledge of Flutter and Dart. If you're new to Flutter, check out the [official Flutter documentation](https://flutter.dev/docs) first.
</Callout>

## Prerequisites

Before you begin, ensure you have:

- Flutter SDK installed (3.0.0 or higher)
- API credentials from CurryDash admin
- Basic understanding of REST APIs and HTTP requests

## 1. Base URLs

CurryDash API uses different base URLs for different environments:

| Environment | Base URL | Use Case |
|-------------|----------|----------|
| Production | `https://api.currydash.com/v1` | Live applications |
| Staging | `https://api-staging.currydash.com/v1` | Testing and QA |
| Development | `http://localhost:8000/api/v1` | Local development |

<Callout type="warning">
  Always use HTTPS in production. HTTP is only acceptable for local development.
</Callout>

## 2. Setup Dependencies

Add the required packages to your `pubspec.yaml`:

```yaml
dependencies:
  dio: ^5.4.0
  flutter_secure_storage: ^9.0.0
  json_annotation: ^4.8.1

dev_dependencies:
  build_runner: ^2.4.7
  json_serializable: ^6.7.1
```

Install the dependencies:

```bash
flutter pub get
```

## 3. Authentication Setup

### Step 1: Create API Client

Create a Dio-based API client to handle HTTP requests:

```dart
// lib/services/api_client.dart
import 'package:dio/dio.dart';

class ApiClient {
  static const String baseUrl = 'https://api.currydash.com/v1';

  final Dio _dio = Dio(
    BaseOptions(
      baseUrl: baseUrl,
      connectTimeout: const Duration(seconds: 30),
      receiveTimeout: const Duration(seconds: 30),
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    ),
  );

  Dio get client => _dio;

  ApiClient() {
    // Add interceptors for logging, auth, etc.
    _dio.interceptors.add(LogInterceptor(
      requestBody: true,
      responseBody: true,
    ));
  }
}
```

### Step 2: Add Authentication Interceptor

Create an interceptor to automatically add authentication tokens to requests:

```dart
// lib/services/auth_interceptor.dart
import 'package:dio/dio.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class AuthInterceptor extends Interceptor {
  final FlutterSecureStorage _storage = const FlutterSecureStorage();

  @override
  void onRequest(
    RequestOptions options,
    RequestInterceptorHandler handler,
  ) async {
    // Retrieve stored token
    final token = await _storage.read(key: 'auth_token');

    if (token != null) {
      // Add Bearer token to request headers
      options.headers['Authorization'] = 'Bearer $token';
    }

    handler.next(options);
  }

  @override
  void onError(
    DioException err,
    ErrorInterceptorHandler handler,
  ) async {
    // Handle 401 Unauthorized - token expired or invalid
    if (err.response?.statusCode == 401) {
      // Clear stored token and redirect to login
      await _storage.delete(key: 'auth_token');
      // TODO: Navigate to login screen
    }

    handler.next(err);
  }
}
```

### Step 3: Register Interceptor

Add the auth interceptor to your API client:

```dart
// In ApiClient constructor
ApiClient() {
  _dio.interceptors.add(AuthInterceptor());
  _dio.interceptors.add(LogInterceptor(
    requestBody: true,
    responseBody: true,
  ));
}
```

## 4. Making Your First API Call

### Step 1: User Login

Let's start by implementing user authentication:

```dart
// lib/services/auth_service.dart
import 'package:dio/dio.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'api_client.dart';

class AuthService {
  final ApiClient _apiClient = ApiClient();
  final FlutterSecureStorage _storage = const FlutterSecureStorage();

  Future<Map<String, dynamic>> login(String email, String password) async {
    try {
      final response = await _apiClient.client.post(
        '/auth/login',
        data: {
          'email': email,
          'password': password,
        },
      );

      // Extract token and user data from response
      final token = response.data['access_token'];
      final user = response.data['user'];

      // Store token securely
      await _storage.write(key: 'auth_token', value: token);

      return {
        'success': true,
        'user': user,
      };
    } on DioException catch (e) {
      return _handleError(e);
    }
  }

  Map<String, dynamic> _handleError(DioException error) {
    if (error.response != null) {
      // Server responded with error
      final errorData = error.response!.data;
      return {
        'success': false,
        'error': errorData['error']['message'] ?? 'Login failed',
      };
    } else {
      // Network error
      return {
        'success': false,
        'error': 'Network error. Please check your connection.',
      };
    }
  }
}
```

### Step 2: Fetch Data

After authentication, you can fetch data from protected endpoints:

```dart
// lib/services/restaurant_service.dart
import 'package:dio/dio.dart';
import 'api_client.dart';

class RestaurantService {
  final ApiClient _apiClient = ApiClient();

  Future<List<dynamic>> getRestaurants({required int zoneId}) async {
    try {
      final response = await _apiClient.client.get(
        '/restaurants',
        queryParameters: {'zone_id': zoneId},
      );

      // API returns data in { "success": true, "data": [...] } format
      if (response.data['success'] == true) {
        return response.data['data'] as List<dynamic>;
      } else {
        throw Exception('Failed to load restaurants');
      }
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Exception _handleError(DioException error) {
    if (error.response != null) {
      final errorData = error.response!.data;
      return Exception(errorData['error']['message'] ?? 'Request failed');
    } else {
      return Exception('Network error');
    }
  }
}
```

### Step 3: Use in UI

Here's how to use the service in a Flutter widget:

```dart
// lib/screens/restaurants_screen.dart
import 'package:flutter/material.dart';
import '../services/restaurant_service.dart';

class RestaurantsScreen extends StatefulWidget {
  @override
  State<RestaurantsScreen> createState() => _RestaurantsScreenState();
}

class _RestaurantsScreenState extends State<RestaurantsScreen> {
  final RestaurantService _restaurantService = RestaurantService();
  List<dynamic> _restaurants = [];
  bool _isLoading = false;
  String? _error;

  @override
  void initState() {
    super.initState();
    _loadRestaurants();
  }

  Future<void> _loadRestaurants() async {
    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final restaurants = await _restaurantService.getRestaurants(zoneId: 1);
      setState(() {
        _restaurants = restaurants;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return Center(child: CircularProgressIndicator());
    }

    if (_error != null) {
      return Center(child: Text('Error: $_error'));
    }

    return ListView.builder(
      itemCount: _restaurants.length,
      itemBuilder: (context, index) {
        final restaurant = _restaurants[index];
        return ListTile(
          title: Text(restaurant['name']),
          subtitle: Text(restaurant['address']),
        );
      },
    );
  }
}
```

## 5. Response Handling

### Success Response Format

All successful API responses follow this structure:

```json
{
  "success": true,
  "data": {
    // Response data here
  },
  "message": "Operation completed successfully"
}
```

### Error Response Format

Error responses follow this structure:

```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error description"
  }
}
```

### Common Response Codes

| HTTP Code | Meaning | Action |
|-----------|---------|--------|
| 200 | Success | Process response data |
| 201 | Created | Resource created successfully |
| 400 | Bad Request | Check request parameters |
| 401 | Unauthorized | Token missing/expired - re-authenticate |
| 403 | Forbidden | User lacks permission |
| 404 | Not Found | Resource doesn't exist |
| 422 | Validation Error | Fix validation errors in request |
| 429 | Rate Limited | Retry after delay |
| 500 | Server Error | Contact support if persists |

### Handle Validation Errors

Validation errors include field-specific details:

```dart
Map<String, dynamic> _handleValidationError(DioException error) {
  if (error.response?.statusCode == 422) {
    final errors = error.response!.data['error']['errors'] as Map<String, dynamic>;

    // errors = {
    //   "email": ["The email field is required."],
    //   "password": ["The password must be at least 8 characters."]
    // }

    return {
      'success': false,
      'validation_errors': errors,
    };
  }

  return {'success': false, 'error': 'Validation failed'};
}
```

## 6. Environment Configuration

Configure different environments using Dart defines:

```dart
// lib/config/environment.dart
class Environment {
  static const String apiBaseUrl = String.fromEnvironment(
    'API_BASE_URL',
    defaultValue: 'https://api.currydash.com/v1',
  );

  static const bool isProduction = bool.fromEnvironment(
    'PRODUCTION',
    defaultValue: false,
  );

  static const bool enableLogging = !isProduction;
}
```

Run with different environments:

```bash
# Development
flutter run --dart-define=API_BASE_URL=http://localhost:8000/api/v1

# Staging
flutter run --dart-define=API_BASE_URL=https://api-staging.currydash.com/v1

# Production
flutter run --dart-define=API_BASE_URL=https://api.currydash.com/v1 --dart-define=PRODUCTION=true
```

## 7. Best Practices

<Callout type="tip">
  Follow these best practices for a robust integration:
</Callout>

1. **Secure Token Storage**: Always use `flutter_secure_storage` for authentication tokens
2. **Error Handling**: Implement comprehensive error handling for all API calls
3. **Loading States**: Show loading indicators during API requests for better UX
4. **Timeout Configuration**: Set appropriate timeouts to handle slow connections
5. **Retry Logic**: Implement retry mechanisms for failed requests
6. **Logging**: Enable detailed logging in development, disable in production
7. **Type Safety**: Use typed models with `json_serializable` instead of dynamic types

## Next Steps

Now that you have the basics set up, explore these topics:

- [API Integration Guide](/api/frontend) - Detailed Flutter integration patterns
- [Backend API Reference](/api/backend) - Complete endpoint documentation
- [Error Handling](/api/frontend/error-handling) - Advanced error handling strategies
- [State Management](/developers/frontend/state-management) - Integrate API with state management

## Common Issues

### "401 Unauthorized" Error

**Cause**: Missing or expired authentication token

**Solution**: Ensure you're calling login first and the token is stored correctly

```dart
// Check if token exists
final token = await _storage.read(key: 'auth_token');
if (token == null) {
  // Redirect to login
}
```

### "Network Error" on Android

**Cause**: Clear text traffic not permitted on Android 9+

**Solution**: Add to `android/app/src/main/AndroidManifest.xml`:

```xml
<application
  android:usesCleartextTraffic="true">
  <!-- Only for local development -->
</application>
```

### CORS Error on Web

**Cause**: Browser blocks cross-origin requests

**Solution**: Contact backend team to add your domain to CORS whitelist

## Support

If you encounter issues:

1. Check the [API Reference](/api/backend) for endpoint details
2. Review error codes in the response
3. Enable Dio logging to see full request/response
4. Contact support at api-support@currydash.com
