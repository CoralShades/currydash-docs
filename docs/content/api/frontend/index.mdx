---
title: Mobile/Web API Integration
description: Flutter API integration guide for CurryDash mobile and web applications
---

import { Cards, Callout } from 'nextra/components'

# Mobile/Web API Integration

Flutter API integration guide for CurryDash mobile and web applications.

<Callout type="info">
  The Flutter apps consume the same Backend REST API documented in the Backend API section. This guide focuses on Flutter-specific integration patterns.
</Callout>

## Architecture Overview

The CurryDash Flutter applications use a clean architecture approach:

- **API Client Layer**: Dio HTTP client for API communication
- **Repository Layer**: Data repositories that abstract API calls
- **State Management**: Provider/Riverpod for state management
- **Model Layer**: Dart data models with JSON serialization

## HTTP Client Setup

CurryDash uses [Dio](https://pub.dev/packages/dio) for HTTP requests:

```dart
import 'package:dio/dio.dart';

class ApiClient {
  final Dio _dio = Dio(
    BaseOptions(
      baseUrl: 'https://api.currydash.com/v1',
      connectTimeout: const Duration(seconds: 30),
      receiveTimeout: const Duration(seconds: 30),
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    ),
  );

  Dio get client => _dio;
}
```

## Authentication

### Bearer Token Authentication

All API requests require a Bearer token in the Authorization header:

```dart
class AuthInterceptor extends Interceptor {
  @override
  void onRequest(
    RequestOptions options,
    RequestInterceptorHandler handler,
  ) async {
    final token = await _getStoredToken();
    if (token != null) {
      options.headers['Authorization'] = 'Bearer $token';
    }
    handler.next(options);
  }

  Future<String?> _getStoredToken() async {
    // Retrieve from secure storage
    final storage = FlutterSecureStorage();
    return await storage.read(key: 'auth_token');
  }
}
```

### Login Example

```dart
class AuthRepository {
  final ApiClient _client;

  Future<User> login(String email, String password) async {
    try {
      final response = await _client.dio.post(
        '/auth/login',
        data: {
          'email': email,
          'password': password,
        },
      );

      final token = response.data['token'];
      final user = User.fromJson(response.data['user']);

      // Store token securely
      await _storeToken(token);

      return user;
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }
}
```

## Error Handling

Centralized error handling for API responses:

```dart
class ApiException implements Exception {
  final String code;
  final String message;
  final int? statusCode;

  ApiException({
    required this.code,
    required this.message,
    this.statusCode,
  });
}

ApiException _handleError(DioException error) {
  if (error.response != null) {
    final data = error.response!.data;
    return ApiException(
      code: data['error']['code'] ?? 'UNKNOWN_ERROR',
      message: data['error']['message'] ?? 'An error occurred',
      statusCode: error.response!.statusCode,
    );
  }

  return ApiException(
    code: 'NETWORK_ERROR',
    message: 'Unable to connect to server',
  );
}
```

## Request Examples

### GET Request

```dart
Future<List<Restaurant>> getRestaurants(int zoneId) async {
  try {
    final response = await _client.dio.get(
      '/restaurants',
      queryParameters: {'zone_id': zoneId},
    );

    return (response.data['data'] as List)
        .map((json) => Restaurant.fromJson(json))
        .toList();
  } on DioException catch (e) {
    throw _handleError(e);
  }
}
```

### POST Request

```dart
Future<Order> createOrder(OrderRequest orderData) async {
  try {
    final response = await _client.dio.post(
      '/orders',
      data: orderData.toJson(),
    );

    return Order.fromJson(response.data['data']);
  } on DioException catch (e) {
    throw _handleError(e);
  }
}
```

### PUT Request

```dart
Future<User> updateProfile(String userId, Map<String, dynamic> updates) async {
  try {
    final response = await _client.dio.put(
      '/users/$userId',
      data: updates,
    );

    return User.fromJson(response.data['data']);
  } on DioException catch (e) {
    throw _handleError(e);
  }
}
```

## Environment Configuration

Use different base URLs for different environments:

```dart
class Config {
  static const String baseUrl = String.fromEnvironment(
    'API_BASE_URL',
    defaultValue: 'https://api.currydash.com/v1',
  );

  static const bool isProduction = bool.fromEnvironment(
    'PRODUCTION',
    defaultValue: false,
  );
}

// Usage in ApiClient
BaseOptions(
  baseUrl: Config.baseUrl,
  // ...
)
```

### Build Commands

```bash
# Development
flutter run --dart-define=API_BASE_URL=http://localhost:8000/api/v1

# Staging
flutter run --dart-define=API_BASE_URL=https://api-staging.currydash.com/v1

# Production
flutter build apk --dart-define=API_BASE_URL=https://api.currydash.com/v1 --dart-define=PRODUCTION=true
```

## Rate Limiting

Handle rate limit responses (HTTP 429):

```dart
class RateLimitInterceptor extends Interceptor {
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    if (err.response?.statusCode == 429) {
      final retryAfter = err.response?.headers['Retry-After']?.first;
      // Show user-friendly message or implement retry logic
    }
    handler.next(err);
  }
}
```

## Model Serialization

Use `json_serializable` for type-safe JSON handling:

```dart
import 'package:json_annotation/json_annotation.dart';

part 'restaurant.g.dart';

@JsonSerializable()
class Restaurant {
  final int id;
  final String name;
  final String address;
  @JsonKey(name: 'phone_number')
  final String phoneNumber;
  final double rating;

  Restaurant({
    required this.id,
    required this.name,
    required this.address,
    required this.phoneNumber,
    required this.rating,
  });

  factory Restaurant.fromJson(Map<String, dynamic> json) =>
      _$RestaurantFromJson(json);

  Map<String, dynamic> toJson() => _$RestaurantToJson(this);
}
```

## Best Practices

1. **Use Interceptors**: Add logging, authentication, and error handling via Dio interceptors
2. **Secure Storage**: Store authentication tokens using `flutter_secure_storage`
3. **Type Safety**: Use generated models with `json_serializable` instead of dynamic types
4. **Error Handling**: Implement centralized error handling for consistent UX
5. **Loading States**: Show loading indicators during API calls
6. **Caching**: Implement caching strategies for frequently accessed data
7. **Offline Support**: Handle offline scenarios gracefully with local storage

## API Endpoint Reference

For detailed endpoint documentation, see the [Backend API](/api/backend) section.

## Common Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/auth/login` | POST | User authentication |
| `/auth/register` | POST | User registration |
| `/restaurants` | GET | List restaurants by zone |
| `/restaurants/{id}` | GET | Restaurant details |
| `/cart` | GET/POST/PUT | Cart management |
| `/orders` | GET/POST | Order operations |
| `/users/profile` | GET/PUT | User profile |

## Debugging

Enable Dio logging for development:

```dart
if (!Config.isProduction) {
  _dio.interceptors.add(
    LogInterceptor(
      requestBody: true,
      responseBody: true,
      error: true,
    ),
  );
}
```
